{"name":"Procmon","tagline":"Procmon alternative for Linux","body":"What is Procmon\r\n=======\r\n\r\nProcmon is a kernel module that hijacks sys calls and sends information about which\r\nprocesses called which sys calls, with what arguments did they call them with, \r\nwhat was the return value, etc, and sends that information to a nice ncurses \r\ninterface.\r\n\r\nSaid in another way, Procmon is like ```strace```, but tracing all and every single\r\nprocess from any user, at any level.\r\n\r\nThat's how it works:\r\n\r\n![How it works](https://raw.github.com/alexandernst/procmon/screenshots/procmon.gif)\r\n\r\nSetting Procmon\r\n=======\r\n\r\nKeep in mind that this is a WIP and you can end up with a totally frozen \r\nkernel! Do *NOT* run this in production machines. I'm *NOT* responsible\r\nfor any data loss or damage in any way.\r\n\r\nIn order to build this module you'll need some basic stuff (make, gcc), the \r\nheaders of the kernel you're running on and ncurses library. Once you have all\r\nthose you just need to run ```make``` inside the root folder of the project.\r\n\r\nLoading the module isn't any different from loading any other module. \r\n```insmod procmon.ko``` for loading it and ```rmmod procmon.ko``` for \r\nunloading it.\r\n\r\nTo start the actual hijack process, once loaded the module, run \r\n```sysctl procmon.state=1```, then you'll probably want to run \r\n```./procmon-viewer``` to see an actual output.\r\n\r\nTo stop it just run hit ```Q```. To stop the module run ```sysctl procmon.state=0```.\r\n\r\nIf your distro has ```libkmod```, you can use procmon's viewer command line\r\nswitches instead to do all those actions (load/unload, start/stop).\r\n\r\nKeep in mind that the module will protect your kernel while unloading. That \r\nmeans that if any process (both in userland and in the kernel itself) expected \r\nto call one of the hijacked syscalls, the module will wait those processes to \r\ncall what they need to call. This may take from 1ms to days. If there's a really \r\nlong delay, try killing/restarting some processes that may have scheduled a \r\ncall. For example, the module won't unload until you press ```Enter``` on all \r\nconsoles that had any activity while the module was loaded.\r\n\r\nThe UI is based on ```ncurses```. Anyways, right now there is almost no functional\r\ncode, just a basic viewer.\r\n\r\n![Screenshot](https://raw.github.com/alexandernst/procmon/screenshots/screenshot1.jpeg)\r\n\r\nWhy Procmon\r\n=======\r\n\r\nI'm completely aware of ```kprobes```, ```perf``` and all other kernel debug \r\nsystems/methods. Probably all of them work better than Procmon, but they have \r\none disadvantage: they require you to recompile the kernel or they are not \r\nenabled by default in some distros.\r\n\r\nYet another reason: I have fun doing it! I don't seek for this project to be \r\nmerged into mainline nor being used by every Linux user out there. I'm doing \r\nit for myself. Anyways, I'd be glad if it works for you too :)\r\n\r\nOn the other hand, Procmon will ```just work```.\r\nWhat this module does to ```just work``` is hijack/replace all \r\n(relevant/interesting) syscalls from the syscall table. While this is risky, \r\nit will allow you to have a similar tool to Procmon for Windows, without having\r\nto recompile the kernel.\r\n\r\nContributing\r\n=======\r\n\r\nJust send me patches, if they are ok I'll give you push access :)\r\n\r\nAbout the editing, note that I'm using ```TAB```s, so please keep it that way.\r\n\r\nLicense\r\n=======\r\n\r\nThe license is WTFPL (Do What The Fuck You Want To Public License), but keep\r\nin mind it's good for both sides if you use this project, fix/add things and\r\npush them back.\r\n","google":"UA-27952342-2","note":"Don't delete this file! It's used internally to help with page regeneration."}