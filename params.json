{"name":"Monks","tagline":"Procmon alternative for Linux","body":"[![Build Status](https://drone.io/github.com/alexandernst/monks/status.png)](https://drone.io/github.com/alexandernst/monks/latest) Procmon alternative for Linux - [Main webpage](http://alexandernst.github.io/monks \"Monks's Homepage\")\r\n\r\nWhat is Monks\r\n=======\r\n\r\nMonks is a kernel module that hijacks sys calls, tracks which processes called\r\nwhich sys calls, with what arguments, what was the return value, etc, and sends\r\nthat information to a nice ncurses interface.\r\n\r\nSaid in another way, Monks is like ```strace```, but tracing all and every single\r\nprocess from any user, at any level.\r\n\r\nThat's how it works:\r\n\r\n![How it works](https://raw.github.com/alexandernst/monks/master/screenshots/monks.gif)\r\n\r\nWhy that name?\r\n=======\r\n\r\nAt first I thought naming the project ```Procmon```, but because that name is already\r\na registered trademark and I don't want any troubles, I decided to call it ```Monks```,\r\nwhich stands for ```MONitoring Kernel Syscalls```.\r\n\r\nSetting Monks\r\n=======\r\n\r\nKeep in mind that this is a WIP and you can end up with a totally frozen \r\nkernel! Do *NOT* run this in production machines. I'm *NOT* responsible\r\nfor any data loss or damage in any way. That said, I test on a daily basis\r\nthis module on quite some virtual machines, 7, to be precise. Both x86 and\r\nx64, different distros, different compilers, different kernels from 2.6.37\r\nup to 3.12.\r\n\r\nIn order to build this module you'll need some basic stuff (make, gcc), the \r\nheaders of the kernel you're running on and ncurses library. Once you have all\r\nthose you just need to run ```make``` inside the root folder of the project.\r\n\r\nLoading the module isn't any different from loading any other module. \r\n```insmod monks.ko``` for loading it and ```rmmod monks.ko``` for \r\nunloading it.\r\n\r\nTo start the actual hijack process, once loaded the module, run \r\n```sysctl monks.state=1```, then you'll probably want to run \r\n```./monks-viewer``` to see an actual output.\r\n\r\nTo stop it just run hit ```q```. To stop the module run ```sysctl monks.state=0```.\r\n\r\nIf your distro has ```libkmod```, you can use monks's viewer command line\r\nswitches instead to do all those actions (load/unload, start/stop).\r\n\r\nThe UI is based on ```ncurses```. Anyways, right now there is almost no functional\r\ncode, just a basic viewer.\r\n\r\n![Screenshot](https://raw.github.com/alexandernst/monks/master/screenshots/screenshot1.jpeg)\r\n\r\nWhy Monks\r\n=======\r\n\r\nI'm completely aware of ```kprobes```, ```perf``` and all other kernel debug \r\nsystems/methods. Probably all of them work better than Monks, but they have \r\none disadvantage: they require you to recompile the kernel or they are not \r\nenabled by default in some distros.\r\n\r\nAlso, Monks will ```just work``` (UI included). What this module does to ```just work``` is\r\nhijack/replace all (relevant/interesting) syscalls from the syscall table.\r\nWhile this is risky, it will allow you to have a similar tool to Procmon for \r\nWindows, without having to recompile the kernel.\r\n\r\nYet another reason: I have fun doing it! I don't seek for this project to be \r\nmerged into mainline nor being used by every Linux user out there. I'm doing \r\nit for myself. Anyways, I'd be glad if it works for you too :)\r\n\r\nContributing\r\n=======\r\n\r\nJust send me patches, if they are ok I'll give you push access :)\r\n\r\nAbout the editing, note that I'm using ```TAB```s, so please keep it that way.\r\n\r\nLicense\r\n=======\r\n\r\nThe license is WTFPL (Do What The Fuck You Want To Public License), but keep\r\nin mind it's good for both sides if you use this project, fix/add things and\r\npush them back.\r\n","google":"UA-27952342-2","note":"Don't delete this file! It's used internally to help with page regeneration."}